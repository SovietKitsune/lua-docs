



<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css" rel="stylesheet">

    
        <meta property="og:title" content="Source inspection - Tealdoc">

        <title>Source inspection - Tealdoc</title>
    

    <script>
    /* PrismJS 1.23.0
    https://prismjs.com/download.html#themes=prism&languages=lua&plugins=line-highlight+normalize-whitespace */
    var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(u){var c=/\blang(?:uage)?-([\w-]+)\b/i,n=0,M={manual:u.Prism&&u.Prism.manual,disableWorkerMessageHandler:u.Prism&&u.Prism.disableWorkerMessageHandler,util:{encode:function e(n){return n instanceof W?new W(n.type,e(n.content),n.alias):Array.isArray(n)?n.map(e):n.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++n}),e.__id},clone:function r(e,t){var a,n;switch(t=t||{},M.util.type(e)){case"Object":if(n=M.util.objId(e),t[n])return t[n];for(var i in a={},t[n]=a,e)e.hasOwnProperty(i)&&(a[i]=r(e[i],t));return a;case"Array":return n=M.util.objId(e),t[n]?t[n]:(a=[],t[n]=a,e.forEach(function(e,n){a[n]=r(e,t)}),a);default:return e}},getLanguage:function(e){for(;e&&!c.test(e.className);)e=e.parentElement;return e?(e.className.match(c)||[,"none"])[1].toLowerCase():"none"},currentScript:function(){if("undefined"==typeof document)return null;if("currentScript"in document)return document.currentScript;try{throw new Error}catch(e){var n=(/at [^(\r\n]*\((.*):.+:.+\)$/i.exec(e.stack)||[])[1];if(n){var r=document.getElementsByTagName("script");for(var t in r)if(r[t].src==n)return r[t]}return null}},isActive:function(e,n,r){for(var t="no-"+n;e;){var a=e.classList;if(a.contains(n))return!0;if(a.contains(t))return!1;e=e.parentElement}return!!r}},languages:{extend:function(e,n){var r=M.util.clone(M.languages[e]);for(var t in n)r[t]=n[t];return r},insertBefore:function(r,e,n,t){var a=(t=t||M.languages)[r],i={};for(var l in a)if(a.hasOwnProperty(l)){if(l==e)for(var o in n)n.hasOwnProperty(o)&&(i[o]=n[o]);n.hasOwnProperty(l)||(i[l]=a[l])}var s=t[r];return t[r]=i,M.languages.DFS(M.languages,function(e,n){n===s&&e!=r&&(this[e]=i)}),i},DFS:function e(n,r,t,a){a=a||{};var i=M.util.objId;for(var l in n)if(n.hasOwnProperty(l)){r.call(n,l,n[l],t||l);var o=n[l],s=M.util.type(o);"Object"!==s||a[i(o)]?"Array"!==s||a[i(o)]||(a[i(o)]=!0,e(o,r,l,a)):(a[i(o)]=!0,e(o,r,null,a))}}},plugins:{},highlightAll:function(e,n){M.highlightAllUnder(document,e,n)},highlightAllUnder:function(e,n,r){var t={callback:r,container:e,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};M.hooks.run("before-highlightall",t),t.elements=Array.prototype.slice.apply(t.container.querySelectorAll(t.selector)),M.hooks.run("before-all-elements-highlight",t);for(var a,i=0;a=t.elements[i++];)M.highlightElement(a,!0===n,t.callback)},highlightElement:function(e,n,r){var t=M.util.getLanguage(e),a=M.languages[t];e.className=e.className.replace(c,"").replace(/\s+/g," ")+" language-"+t;var i=e.parentElement;i&&"pre"===i.nodeName.toLowerCase()&&(i.className=i.className.replace(c,"").replace(/\s+/g," ")+" language-"+t);var l={element:e,language:t,grammar:a,code:e.textContent};function o(e){l.highlightedCode=e,M.hooks.run("before-insert",l),l.element.innerHTML=l.highlightedCode,M.hooks.run("after-highlight",l),M.hooks.run("complete",l),r&&r.call(l.element)}if(M.hooks.run("before-sanity-check",l),!l.code)return M.hooks.run("complete",l),void(r&&r.call(l.element));if(M.hooks.run("before-highlight",l),l.grammar)if(n&&u.Worker){var s=new Worker(M.filename);s.onmessage=function(e){o(e.data)},s.postMessage(JSON.stringify({language:l.language,code:l.code,immediateClose:!0}))}else o(M.highlight(l.code,l.grammar,l.language));else o(M.util.encode(l.code))},highlight:function(e,n,r){var t={code:e,grammar:n,language:r};return M.hooks.run("before-tokenize",t),t.tokens=M.tokenize(t.code,t.grammar),M.hooks.run("after-tokenize",t),W.stringify(M.util.encode(t.tokens),t.language)},tokenize:function(e,n){var r=n.rest;if(r){for(var t in r)n[t]=r[t];delete n.rest}var a=new i;return I(a,a.head,e),function e(n,r,t,a,i,l){for(var o in t)if(t.hasOwnProperty(o)&&t[o]){var s=t[o];s=Array.isArray(s)?s:[s];for(var u=0;u<s.length;++u){if(l&&l.cause==o+","+u)return;var c=s[u],g=c.inside,f=!!c.lookbehind,h=!!c.greedy,d=c.alias;if(h&&!c.pattern.global){var v=c.pattern.toString().match(/[imsuy]*$/)[0];c.pattern=RegExp(c.pattern.source,v+"g")}for(var p=c.pattern||c,m=a.next,y=i;m!==r.tail&&!(l&&y>=l.reach);y+=m.value.length,m=m.next){var k=m.value;if(r.length>n.length)return;if(!(k instanceof W)){var b,x=1;if(h){if(!(b=z(p,y,n,f)))break;var w=b.index,A=b.index+b[0].length,P=y;for(P+=m.value.length;P<=w;)m=m.next,P+=m.value.length;if(P-=m.value.length,y=P,m.value instanceof W)continue;for(var S=m;S!==r.tail&&(P<A||"string"==typeof S.value);S=S.next)x++,P+=S.value.length;x--,k=n.slice(y,P),b.index-=y}else if(!(b=z(p,0,k,f)))continue;var w=b.index,E=b[0],O=k.slice(0,w),L=k.slice(w+E.length),N=y+k.length;l&&N>l.reach&&(l.reach=N);var j=m.prev;O&&(j=I(r,j,O),y+=O.length),q(r,j,x);var C=new W(o,g?M.tokenize(E,g):E,d,E);if(m=I(r,j,C),L&&I(r,m,L),1<x){var _={cause:o+","+u,reach:N};e(n,r,t,m.prev,y,_),l&&_.reach>l.reach&&(l.reach=_.reach)}}}}}}(e,a,n,a.head,0),function(e){var n=[],r=e.head.next;for(;r!==e.tail;)n.push(r.value),r=r.next;return n}(a)},hooks:{all:{},add:function(e,n){var r=M.hooks.all;r[e]=r[e]||[],r[e].push(n)},run:function(e,n){var r=M.hooks.all[e];if(r&&r.length)for(var t,a=0;t=r[a++];)t(n)}},Token:W};function W(e,n,r,t){this.type=e,this.content=n,this.alias=r,this.length=0|(t||"").length}function z(e,n,r,t){e.lastIndex=n;var a=e.exec(r);if(a&&t&&a[1]){var i=a[1].length;a.index+=i,a[0]=a[0].slice(i)}return a}function i(){var e={value:null,prev:null,next:null},n={value:null,prev:e,next:null};e.next=n,this.head=e,this.tail=n,this.length=0}function I(e,n,r){var t=n.next,a={value:r,prev:n,next:t};return n.next=a,t.prev=a,e.length++,a}function q(e,n,r){for(var t=n.next,a=0;a<r&&t!==e.tail;a++)t=t.next;(n.next=t).prev=n,e.length-=a}if(u.Prism=M,W.stringify=function n(e,r){if("string"==typeof e)return e;if(Array.isArray(e)){var t="";return e.forEach(function(e){t+=n(e,r)}),t}var a={type:e.type,content:n(e.content,r),tag:"span",classes:["token",e.type],attributes:{},language:r},i=e.alias;i&&(Array.isArray(i)?Array.prototype.push.apply(a.classes,i):a.classes.push(i)),M.hooks.run("wrap",a);var l="";for(var o in a.attributes)l+=" "+o+'="'+(a.attributes[o]||"").replace(/"/g,"&quot;")+'"';return"<"+a.tag+' class="'+a.classes.join(" ")+'"'+l+">"+a.content+"</"+a.tag+">"},!u.document)return u.addEventListener&&(M.disableWorkerMessageHandler||u.addEventListener("message",function(e){var n=JSON.parse(e.data),r=n.language,t=n.code,a=n.immediateClose;u.postMessage(M.highlight(t,M.languages[r],r)),a&&u.close()},!1)),M;var e=M.util.currentScript();function r(){M.manual||M.highlightAll()}if(e&&(M.filename=e.src,e.hasAttribute("data-manual")&&(M.manual=!0)),!M.manual){var t=document.readyState;"loading"===t||"interactive"===t&&e&&e.defer?document.addEventListener("DOMContentLoaded",r):window.requestAnimationFrame?window.requestAnimationFrame(r):window.setTimeout(r,16)}return M}(_self);"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
    Prism.languages.lua={comment:/^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,string:{pattern:/(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,greedy:!0},number:/\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,keyword:/\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,function:/(?!\d)\w+(?=\s*(?:[({]))/,operator:[/[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,{pattern:/(^|[^.])\.\.(?!\.)/,lookbehind:!0}],punctuation:/[\[\](){},;]|\.+|:+/};
    
    !function(){if("undefined"!=typeof self&&self.Prism&&self.document&&document.querySelector){var t,o="line-numbers",s="linkable-line-numbers",a=function(){if(void 0===t){var e=document.createElement("div");e.style.fontSize="13px",e.style.lineHeight="1.5",e.style.padding="0",e.style.border="0",e.innerHTML="&nbsp;<br />&nbsp;",document.body.appendChild(e),t=38===e.offsetHeight,document.body.removeChild(e)}return t},l=!0,u=0;Prism.hooks.add("before-sanity-check",function(e){var t=e.element.parentElement;if(c(t)){var n=0;v(".line-highlight",t).forEach(function(e){n+=e.textContent.length,e.parentNode.removeChild(e)}),n&&/^( \n)+$/.test(e.code.slice(-n))&&(e.code=e.code.slice(0,-n))}}),Prism.hooks.add("complete",function e(t){var n=t.element.parentElement;if(c(n)){clearTimeout(u);var i=Prism.plugins.lineNumbers,r=t.plugins&&t.plugins.lineNumbers;if(b(n,o)&&i&&!r)Prism.hooks.add("line-numbers",e);else d(n)(),u=setTimeout(f,1)}}),window.addEventListener("hashchange",f),window.addEventListener("resize",function(){v("pre").filter(c).map(function(e){return d(e)}).forEach(y)})}function v(e,t){return Array.prototype.slice.call((t||document).querySelectorAll(e))}function b(e,t){return e.classList.contains(t)}function y(e){e()}function c(e){return!(!e||!/pre/i.test(e.nodeName))&&(!!e.hasAttribute("data-line")||!(!e.id||!Prism.util.isActive(e,s)))}function d(u,e,c){var t=(e="string"==typeof e?e:u.getAttribute("data-line")||"").replace(/\s+/g,"").split(",").filter(Boolean),d=+u.getAttribute("data-line-offset")||0,f=(a()?parseInt:parseFloat)(getComputedStyle(u).lineHeight),p=Prism.util.isActive(u,o),n=u.querySelector("code"),h=p?u:n||u,m=[],g=n&&h!=n?function(e,t){var n=getComputedStyle(e),i=getComputedStyle(t);function r(e){return+e.substr(0,e.length-2)}return t.offsetTop+r(i.borderTopWidth)+r(i.paddingTop)-r(n.paddingTop)}(u,n):0;t.forEach(function(e){var t=e.split("-"),n=+t[0],i=+t[1]||n,r=u.querySelector('.line-highlight[data-range="'+e+'"]')||document.createElement("div");if(m.push(function(){r.setAttribute("aria-hidden","true"),r.setAttribute("data-range",e),r.className=(c||"")+" line-highlight"}),p&&Prism.plugins.lineNumbers){var o=Prism.plugins.lineNumbers.getLine(u,n),s=Prism.plugins.lineNumbers.getLine(u,i);if(o){var a=o.offsetTop+g+"px";m.push(function(){r.style.top=a})}if(s){var l=s.offsetTop-o.offsetTop+s.offsetHeight+"px";m.push(function(){r.style.height=l})}}else m.push(function(){r.setAttribute("data-start",String(n)),n<i&&r.setAttribute("data-end",String(i)),r.style.top=(n-d-1)*f+g+"px",r.textContent=new Array(i-n+2).join(" \n")});m.push(function(){h.appendChild(r)})});var i=u.id;if(p&&Prism.util.isActive(u,s)&&i){b(u,s)||m.push(function(){u.classList.add(s)});var r=parseInt(u.getAttribute("data-start")||"1");v(".line-numbers-rows > span",u).forEach(function(e,t){var n=t+r;e.onclick=function(){var e=i+"."+n;l=!1,location.hash=e,setTimeout(function(){l=!0},1)}})}return function(){m.forEach(y)}}function f(){var e=location.hash.slice(1);v(".temporary.line-highlight").forEach(function(e){e.parentNode.removeChild(e)});var t=(e.match(/\.([\d,-]+)$/)||[,""])[1];if(t&&!document.getElementById(e)){var n=e.slice(0,e.lastIndexOf(".")),i=document.getElementById(n);if(i)i.hasAttribute("data-line")||i.setAttribute("data-line",""),d(i,t,"temporary ")(),l&&document.querySelector(".temporary.line-highlight").scrollIntoView()}}}();
    !function(){var i=Object.assign||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t]);return e};function e(e){this.defaults=i({},e)}function s(e){for(var n=0,t=0;t<e.length;++t)e.charCodeAt(t)=="\t".charCodeAt(0)&&(n+=3);return e.length+n}e.prototype={setDefaults:function(e){this.defaults=i(this.defaults,e)},normalize:function(e,n){for(var t in n=i(this.defaults,n)){var r=t.replace(/-(\w)/g,function(e,n){return n.toUpperCase()});"normalize"!==t&&"setDefaults"!==r&&n[t]&&this[r]&&(e=this[r].call(this,e,n[t]))}return e},leftTrim:function(e){return e.replace(/^\s+/,"")},rightTrim:function(e){return e.replace(/\s+$/,"")},tabsToSpaces:function(e,n){return n=0|n||4,e.replace(/\t/g,new Array(++n).join(" "))},spacesToTabs:function(e,n){return n=0|n||4,e.replace(RegExp(" {"+n+"}","g"),"\t")},removeTrailing:function(e){return e.replace(/\s*?$/gm,"")},removeInitialLineFeed:function(e){return e.replace(/^(?:\r?\n|\r)/,"")},removeIndent:function(e){var n=e.match(/^[^\S\n\r]*(?=\S)/gm);return n&&n[0].length?(n.sort(function(e,n){return e.length-n.length}),n[0].length?e.replace(RegExp("^"+n[0],"gm"),""):e):e},indent:function(e,n){return e.replace(/^[^\S\n\r]*(?=\S)/gm,new Array(++n).join("\t")+"$&")},breakLines:function(e,n){n=!0===n?80:0|n||80;for(var t=e.split("\n"),r=0;r<t.length;++r)if(!(s(t[r])<=n)){for(var i=t[r].split(/(\s+)/g),o=0,a=0;a<i.length;++a){var l=s(i[a]);n<(o+=l)&&(i[a]="\n"+i[a],o=l)}t[r]=i.join("")}return t.join("\n")}},"undefined"!=typeof module&&module.exports&&(module.exports=e),"undefined"!=typeof Prism&&(Prism.plugins.NormalizeWhitespace=new e({"remove-trailing":!0,"remove-indent":!0,"left-trim":!0,"right-trim":!0}),Prism.hooks.add("before-sanity-check",function(e){var n=Prism.plugins.NormalizeWhitespace;if((!e.settings||!1!==e.settings["whitespace-normalization"])&&Prism.util.isActive(e.element,"whitespace-normalization",!0))if(e.element&&e.element.parentNode||!e.code){var t=e.element.parentNode;if(e.code&&t&&"pre"===t.nodeName.toLowerCase()){for(var r=t.childNodes,i="",o="",a=!1,l=0;l<r.length;++l){var s=r[l];s==e.element?a=!0:"#text"===s.nodeName&&(a?o+=s.nodeValue:i+=s.nodeValue,t.removeChild(s),--l)}if(e.element.children.length&&Prism.plugins.KeepMarkup){var c=i+e.element.innerHTML+o;e.element.innerHTML=n.normalize(c,e.settings),e.code=e.element.textContent}else e.code=i+e.code+o,e.code=n.normalize(e.code,e.settings)}}else e.code=n.normalize(e.code,e.settings)}))}();
</script>

<style>
/* PrismJS 1.23.0
https://prismjs.com/download.html#themes=prism&languages=lua+moonscript&plugins=line-highlight+line-numbers */
/**
* prism.js default theme for JavaScript, CSS and HTML
* Based on dabblet (http://dabblet.com)
* @author Lea Verou
*/

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    font-size: 1em;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;

    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;

    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.token.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    /* This background color was intended by the author of this theme. */
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}

pre[data-line] {
    position: relative;
    padding: 1em 0 1em 3em;
}

.line-highlight {
    position: absolute;
    left: 0;
    right: 0;
    padding: inherit 0;
    margin-top: 1em; /* Same as .prism’s padding-top */

    background: hsla(24, 20%, 50%,.08);
    background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));

    pointer-events: none;

    line-height: inherit;
    white-space: pre;
}

@media print {
    .line-highlight {
        /*
        * This will prevent browsers from replacing the background color with white.
        * It's necessary because the element is layered on top of the displayed code.
        */
        -webkit-print-color-adjust: exact;
        color-adjust: exact;
    }
}

    .line-highlight:before,
    .line-highlight[data-end]:after {
        content: attr(data-start);
        position: absolute;
        top: .4em;
        left: .6em;
        min-width: 1em;
        padding: 0 .5em;
        background-color: hsla(24, 20%, 50%,.4);
        color: hsl(24, 20%, 95%);
        font: bold 65%/1.5 sans-serif;
        text-align: center;
        vertical-align: .3em;
        border-radius: 999px;
        text-shadow: none;
        box-shadow: 0 1px white;
    }

    .line-highlight[data-end]:after {
        content: attr(data-end);
        top: auto;
        bottom: .4em;
    }

.line-numbers .line-highlight:before,
.line-numbers .line-highlight:after {
    content: none;
}

pre[id].linkable-line-numbers span.line-numbers-rows {
    pointer-events: all;
}
pre[id].linkable-line-numbers span.line-numbers-rows > span:before {
    cursor: pointer;
}
pre[id].linkable-line-numbers span.line-numbers-rows > span:hover:before {
    background-color: rgba(128, 128, 128, .2);
}

pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

.line-numbers-rows > span {
    display: block;
    counter-increment: linenumber;
}

.line-numbers-rows > span:before {
    content: counter(linenumber);
    color: #999;
    display: block;
    padding-right: 0.8em;
    text-align: right;
}
</style>

</head>


<body>
    <!-- 
    TODO
    > * Show you the types of identifiers on hover.
    > * Take you to the definition of a variable on click.
    > * Both of these work cross-package.
    Basically use the teal compiler to extract all of this at compile time,

    Cross-package is going to be more tricky
    -->
    <pre id="code" class="linkable-line-numbers">
        <code class="language-lua">
local parser = require(&#039;tealdoc.parser&#039;)
local logger = require(&#039;tealdoc.logger&#039;)
local tag = require(&#039;tealdoc.tag&#039;)

local lunamark = require(&#039;lunamark&#039;)
local argparse = require(&#039;argparse&#039;)
local etlua = require(&#039;etlua&#039;)
local lfs = require(&#039;lfs&#039;)

--- The configuration passed to templates
local record Project
   name: string
   version: string
   deprecated: boolean | string
   description: string
   module: parser.Type | nil
   modules: {string: parser.Type} | nil
   sources: {string: string}
   functionStyle: string
   output: string
end

--- The user-provided configuration
local record Config
   --- @{hidden}
   enum FunctionStyle
      &#039;lua&#039;
      &#039;moon&#039;
   end
   --- @{hidden}
   enum TagStyle
      &#039;ldoc&#039;
      &#039;tealdoc&#039;
      &#039;none&#039;
   end
   --- The name of the project, if not provided this will be taken from a rockspec
   name: string
   --- The version of the project, if not provided this will be taken from a rockspec
   version: string
   --- If the project is deprecated and why it was deprecated
   deprecated: boolean | string
   --- The description of the project, if not provided this will be taken from:
   ---
   --- `descriptionFile -&gt; rockspec.description.detailed -&gt; rockspec.description.summary -&gt; readme.md`
   description: string
   --- The file to use for the description
   descriptionFile: string
   --- If the project is written in Lua, defaults to false
   isLua: boolean
   --- The function style, defaults to `lua`
   ---
   --- `lua`:
   ---
   --- ```lua
   --- function foo(bar: baz): baz
   --- ```
   ---
   --- `moon`:
   ---
   --- ```moon
   --- foo = (bar: baz) -&gt; baz
   --- ```
   functionStyle: FunctionStyle
   --- The output directory, defaults to `docs/`
   output: string
   --- Where to find all the project source files, defaults to current working directory
   source: string
   --- The tag format that should be used, this usually doesn&#039;t matter for Teal besides for hiding and deprecations
   ---
   --- The default is `tealdoc`
   ---
   --- `tealdoc`:
   ---
   --- Note that the `-` after `@` is only there to escape the tag
   ---
   --- ```lua
   --- --- This is a cool function
   --- -- @-{param y number}
   --- -- @-{return number}
   --- local function x(y)
   ---    return y
   --- end
   --- ```
   ---
   --- `ldoc`:
   ---
   --- ```lua
   --- --- This is a cool function
   --- -- @tparam number y
   --- -- @treturn number
   --- local function x(y)
   ---    return y
   --- end
   --- ```
   ---
   --- `none`:
   ---
   --- Doesn&#039;t preload any tags
   tagStyle: TagStyle
   --- The directories where extra tags are located
   tags: {string}
end

local record ConfigRockspec
   record Description
      summary: string
      detailed: string
   end
   package: string
   version: string
   description: Description
end

local function dirTree(dir: string, current: {string: string}, depth: string): {string: string}
   local tree = current or {}

   depth = (depth or &#039;&#039;) .. (dir:match(&#039;.*/(.*)$&#039;) or dir)

   if depth ~= &#039;&#039; then
      depth = depth .. &#039;.&#039;
   end

   depth = depth:match(&#039;%.*(.*)&#039;)

   for path in lfs.dir(dir) do
      if path ~= &#039;.&#039; and path ~= &#039;..&#039; then
         local attributes = lfs.attributes(dir .. &#039;/&#039; .. path)

         if attributes.mode == &#039;file&#039; and (path:match(&#039;%.lua$&#039;) or path:match(&#039;%.tl$&#039;)) then
            tree[depth .. path:match(&#039;(.-)%.(.*)&#039;)] = dir .. &#039;/&#039; .. path
         elseif attributes.mode == &#039;directory&#039; then
            dirTree(dir .. &#039;/&#039; .. path, tree, depth)
         end
      end
   end

   return tree
end

local function search(pat: string, dirs: {string}): string
   for i = 1, #dirs do
      if lfs.attributes(dirs[i]) and lfs.attributes(dirs[i]).mode == &#039;directory&#039; then
         for path in lfs.dir(dirs[i]) do
            if path:match(pat) then
               return path
            end
         end
      end
   end
end

local function recursiveDir(path: string, pat: string | nil, current: {string}): {string}
   current = current or {}

   for location in lfs.dir(path) do
      if location ~= &#039;.&#039; and location ~= &#039;..&#039; then

         if lfs.attributes(path .. &#039;/&#039; .. location).mode == &#039;directory&#039; then
            recursiveDir(path .. &#039;/&#039; .. location, pat, current)
         elseif lfs.attributes(path .. &#039;/&#039; .. location).mode == &#039;file&#039; and location:match(pat) then
            table.insert(current, path .. &#039;/&#039; .. location)
         end
      end
   end

   return current
end

local function currentLocation(): string
   local str = debug.getinfo(2, &#039;S&#039;).source:sub(2)

   -- The CLI is **never** ran directly from the interpreter

   return str:match(&#039;(.*/)&#039;)
end

local function read(path: string): string
   local f = assert(io.open(path, &#039;r&#039;))

   local data = f:read(&#039;*a&#039;)

   f:close()

   return data
end

local function loadTag(file: string): any
   local data = read(file)

   local fn = assert(load(data, &#039;tag&#039;))

   return fn()
end

local function loadTags(config: Config): {tag.TagConfig}
   local files = {}

   local defaultTags = currentLocation() .. &#039;/tags/&#039;

   if config.tagStyle == &#039;ldoc&#039; then
      logger.warn(&#039;LDoc support hasn\&#039;t been implemented yet!&#039;)
      recursiveDir(defaultTags .. &#039;ldoc&#039;, &#039;%.lua$&#039;, files)
   elseif config.tagStyle == &#039;tealdoc&#039; then
      recursiveDir(defaultTags .. &#039;tealdoc&#039;, &#039;%.lua$&#039;, files)
   elseif config.tagStyle ~= &#039;none&#039; then
      logger.error(&#039;Unrecognized tag style: &#039; .. config.tagStyle)
   end

   config.tags = config.tags or {}

   for i = 1, #config.tags do
      recursiveDir(config.tags[i], &#039;%.lua$&#039;, files)
   end

   local tags = {}

   for i = 1, #files do
      table.insert(tags, loadTag(files[i]))
   end

   return tags as {tag.TagConfig}
end

local function write(path: string, data: string)
   local f = assert(io.open(path, &#039;w&#039;))

   f:write(data)

   f:close()
end

local function loadSpec(spec: string): ConfigRockspec
   local data = read(spec)

   local env = {}

   local fn = assert(load(data, &#039;rockspec&#039;, &#039;t&#039;, env))

   if tonumber(_VERSION:match(&#039;Lua ([%d%.]+)&#039;)) &lt; 5.2 then
      global setfenv: function(function, table)

      -- Lua 5.1 compat
      setfenv(fn, env)
   end

   pcall(fn)

   return env as ConfigRockspec
end

local function loadConfig(contents: string): Config
   -- Dynamic requires in teal
   local fn = assert(load(contents, &#039;config&#039;))

   return fn() as Config
end

-- Everything is described in the config
local argParser = argparse(&#039;tealdoc&#039;, &#039;A documentation generator for Teal and by extension Lua&#039;)

argParser:option(&#039;-c --config&#039;, &#039;The configuration file location&#039;, &#039;tealdoc.lua&#039;, io.open)
argParser:flag(&#039;-q --quiet&#039;, &#039;Suppress output&#039;)

--- The entry-point of the CLI
---
--- Flags:
---
--- * `-c`/`--config` - The configuration file location
--- * `-q`/`--quiet` - Suppress output
local function main()
   local parsed = argParser:parse()

   logger.level =
      (parsed.quiet and 1) or
      (os.getenv(&#039;DEBUG&#039;) and 5) or
      3

   logger.color = not os.getenv(&#039;NO_COLOR&#039;)

   local fileContents = (parsed.config as FILE):read(&#039;*a&#039;)

   local config = loadConfig(fileContents)

   local rockspec: ConfigRockspec
   -- Fallback to rockspec
   local spec = search(&#039;.*%.rockspec&#039;, {&#039;.&#039;, &#039;rockspecs&#039;})

   if spec then
      rockspec = loadSpec(spec)
   end

   if not config then
      logger.error(&#039;Expected config to have a `[project]` section&#039;)

      os.exit(-1)
   end

   local project = {} as Project

   project.name = config.name or rockspec.package or error(&#039;Expected package to have a name&#039;)
   project.version = config.version or rockspec.version or &#039;&#039;
   project.description =
      config.description or
      (config.descriptionFile and read(config.descriptionFile)) or
      (rockspec.description and rockspec.description.detailed or rockspec.description.summary) or
      (lfs.attributes(&#039;readme.md&#039;) and read(&#039;readme.md&#039;)) or
      &#039;&#039;
   project.deprecated = config.deprecated
   project.functionStyle = config.functionStyle or &#039;lua&#039;

   if not config.source then
      config.source = tostring(config.name)
   end

   config.output = config.output or &#039;docs&#039;
   config.tagStyle = config.tagStyle or &#039;tealdoc&#039;

   project.output = config.output

   if not config.output then
      lfs.mkdir(config.output)
   end

   assert(lfs.attributes(config.source))

   local tree = dirTree(config.source)

   local state = parser.getReport(tree, false, config.isLua)

   project.sources = state.files

   local mods = parser.extractModules(state, tree)

   local types = {}
   local count = 0
   local first: string

   for i, v in pairs(mods) do
      types[i] = parser.createType(v, state)

      count = count + 1

      if not first then
         first = i
      end
   end

   if count == 1 then
      project.module = types[first]
   else
      project.modules = types
   end

   local writer = lunamark.writer.html.new({})

   -- Change some defaults since of tailwind messing with them

   writer.link = function(label: string, uri: string, title: string): {string}
      local titleAtt = &#039;&#039;

      if type(title) == &#039;string&#039; and #title &gt; 0 then
         titleAtt = &#039;title=&quot;&#039; .. title .. &#039;&quot;&#039;
      end

      return {&#039;&lt;a href=&quot;&#039;, uri, &#039;&quot; class=&quot;text-blue-500&quot; &#039;, titleAtt, &#039;&gt;&#039;, label, &#039;&lt;/a&gt;&#039;}
   end

   writer.header = function(str: string, level: number): {string}
      local textMaps = {
         &#039;3xl&#039;,
         &#039;2xl&#039;,
         &#039;xl&#039;,
         &#039;lg&#039;,
         &#039;base&#039;,
         &#039;base&#039;
      }

      return {&#039;&lt;h&#039;, tostring(level), &#039; class=&quot;text-&#039;, textMaps[level], &#039;&quot;&gt;&#039;, str, &#039;&lt;/h&#039;, tostring(level), &#039;&gt;&#039;}
   end

   -- We don&#039;t want anything else
   writer.template = &#039;$body&#039;

   writer.paragraph = function(str: string): {string}
      return {&#039;&lt;p class=&quot;py-2&quot;&gt;&#039;, str, &#039;&lt;/p&gt;&#039;}
   end

   local markdown = lunamark.reader.markdown.new(writer, {
      fenced_code_blocks = true --;ignore
   })

   local scriptDir = currentLocation()
   local cache: {string: function(any): string} = {}

   local function include(filename: string, base: table): string
      base = base or {}

      base.project = project
      base.include = function(f: string, b: table): string
         b = b or {}

         for i, v in pairs(base) do
            b[i] = v
         end

         return include(f, b)
      end

      cache[filename] = cache[filename] or etlua.compile(read(scriptDir .. &#039;templates/&#039; .. filename))

      return cache[filename](base)
   end

   -- Templates --
   local humanize = require(&#039;tealdoc.humanize&#039;)(project as table)

   local module = assert(etlua.compile(read(scriptDir .. &#039;templates/module.etlua&#039;)))
   local document = assert(etlua.compile(read(scriptDir .. &#039;templates/document.etlua&#039;)))
   local srcdoc = assert(etlua.compile(read(scriptDir .. &#039;templates/srcdoc.etlua&#039;)))

   local function genDocument(name: string, tp: parser.Type)
      local location: string

      -- I feel like this will lead to recursion
      tp.tree = tp.parent and (tp.parent as parser.Type).tree or &#039;&#039;

      tp.name = name

      if tp.kind == &#039;custom&#039; and not tp.struct.isRecord then
         tp.tree = tp.tree .. &#039;/&#039; .. name

         lfs.mkdir(config.output .. &#039;/&#039; .. tp.tree)

         location = config.output .. tp.tree .. &#039;/index.html&#039;

         write(location, module({
            project = project,
            current = tp,
            include = include,
            humanize = humanize,
            markdown = markdown
         }))

         for i, v in pairs(tp.struct.fields) do
            -- Generate children
            if not v.hidden then
               genDocument(i, v)
            end
         end
      else
         -- Non-modules get a document
         location = config.output .. tp.tree .. &#039;/&#039; .. name .. &#039;.html&#039;

         write(location, document({
            project = project,
            current = tp,
            humanize = humanize,
            markdown = markdown,
            include = include
         }))
      end

      logger.info(&#039;Generated &#039; .. location)
   end

   local tags = loadTags(config)

   tag.traverse(project.modules or {
      [project.name] = project.module as parser.Type
   }, tags)

   write(config.output .. &#039;/index.html&#039;, module({
      current = project,
      project = project,
      include = include,
      humanize = humanize,
      markdown = markdown
   }))

   logger.info(&#039;Generated &#039; .. config.output .. &#039;/index.html&#039;)

   if project.module then
      assert(not (project.module as parser.Type).hidden, &#039;Hiding the entire project sounds a bit stupid doesn\&#039;t it?&#039;)
      genDocument(project.name, project.module as parser.Type)
   else
      for i, v in pairs((project.modules as {string: parser.Type})) do
         if not v.hidden then
            genDocument(i, v)
         end
      end
   end

   -- Generate sources

   lfs.mkdir(config.output .. &#039;/&#039; .. &#039;sources&#039;)

   for i, v in pairs(project.sources) do
      write(config.output .. &#039;/sources/&#039; .. i:gsub(&#039;/&#039;, &#039;-&#039;) .. &#039;.html&#039;, srcdoc({
         code = v,
         include = include
      }))

      logger.info(&#039;Generated &#039; .. config.output .. &#039;/sources/&#039; .. i:gsub(&#039;/&#039;, &#039;-&#039;) .. &#039;.html&#039;)
   end
end

--- The main function of the documentation generator as well as the project config
return {
   Project = Project,
   Config = Config,
   main = main
}

        </code>
    </pre>
</body>
</html>
