

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="og:title" content="Source inspection - Tealdoc">

    <script>
    /* PrismJS 1.23.0
    https://prismjs.com/download.html#themes=prism&languages=lua&plugins=line-highlight+normalize-whitespace */
    var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(u){var c=/\blang(?:uage)?-([\w-]+)\b/i,n=0,M={manual:u.Prism&&u.Prism.manual,disableWorkerMessageHandler:u.Prism&&u.Prism.disableWorkerMessageHandler,util:{encode:function e(n){return n instanceof W?new W(n.type,e(n.content),n.alias):Array.isArray(n)?n.map(e):n.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++n}),e.__id},clone:function r(e,t){var a,n;switch(t=t||{},M.util.type(e)){case"Object":if(n=M.util.objId(e),t[n])return t[n];for(var i in a={},t[n]=a,e)e.hasOwnProperty(i)&&(a[i]=r(e[i],t));return a;case"Array":return n=M.util.objId(e),t[n]?t[n]:(a=[],t[n]=a,e.forEach(function(e,n){a[n]=r(e,t)}),a);default:return e}},getLanguage:function(e){for(;e&&!c.test(e.className);)e=e.parentElement;return e?(e.className.match(c)||[,"none"])[1].toLowerCase():"none"},currentScript:function(){if("undefined"==typeof document)return null;if("currentScript"in document)return document.currentScript;try{throw new Error}catch(e){var n=(/at [^(\r\n]*\((.*):.+:.+\)$/i.exec(e.stack)||[])[1];if(n){var r=document.getElementsByTagName("script");for(var t in r)if(r[t].src==n)return r[t]}return null}},isActive:function(e,n,r){for(var t="no-"+n;e;){var a=e.classList;if(a.contains(n))return!0;if(a.contains(t))return!1;e=e.parentElement}return!!r}},languages:{extend:function(e,n){var r=M.util.clone(M.languages[e]);for(var t in n)r[t]=n[t];return r},insertBefore:function(r,e,n,t){var a=(t=t||M.languages)[r],i={};for(var l in a)if(a.hasOwnProperty(l)){if(l==e)for(var o in n)n.hasOwnProperty(o)&&(i[o]=n[o]);n.hasOwnProperty(l)||(i[l]=a[l])}var s=t[r];return t[r]=i,M.languages.DFS(M.languages,function(e,n){n===s&&e!=r&&(this[e]=i)}),i},DFS:function e(n,r,t,a){a=a||{};var i=M.util.objId;for(var l in n)if(n.hasOwnProperty(l)){r.call(n,l,n[l],t||l);var o=n[l],s=M.util.type(o);"Object"!==s||a[i(o)]?"Array"!==s||a[i(o)]||(a[i(o)]=!0,e(o,r,l,a)):(a[i(o)]=!0,e(o,r,null,a))}}},plugins:{},highlightAll:function(e,n){M.highlightAllUnder(document,e,n)},highlightAllUnder:function(e,n,r){var t={callback:r,container:e,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};M.hooks.run("before-highlightall",t),t.elements=Array.prototype.slice.apply(t.container.querySelectorAll(t.selector)),M.hooks.run("before-all-elements-highlight",t);for(var a,i=0;a=t.elements[i++];)M.highlightElement(a,!0===n,t.callback)},highlightElement:function(e,n,r){var t=M.util.getLanguage(e),a=M.languages[t];e.className=e.className.replace(c,"").replace(/\s+/g," ")+" language-"+t;var i=e.parentElement;i&&"pre"===i.nodeName.toLowerCase()&&(i.className=i.className.replace(c,"").replace(/\s+/g," ")+" language-"+t);var l={element:e,language:t,grammar:a,code:e.textContent};function o(e){l.highlightedCode=e,M.hooks.run("before-insert",l),l.element.innerHTML=l.highlightedCode,M.hooks.run("after-highlight",l),M.hooks.run("complete",l),r&&r.call(l.element)}if(M.hooks.run("before-sanity-check",l),!l.code)return M.hooks.run("complete",l),void(r&&r.call(l.element));if(M.hooks.run("before-highlight",l),l.grammar)if(n&&u.Worker){var s=new Worker(M.filename);s.onmessage=function(e){o(e.data)},s.postMessage(JSON.stringify({language:l.language,code:l.code,immediateClose:!0}))}else o(M.highlight(l.code,l.grammar,l.language));else o(M.util.encode(l.code))},highlight:function(e,n,r){var t={code:e,grammar:n,language:r};return M.hooks.run("before-tokenize",t),t.tokens=M.tokenize(t.code,t.grammar),M.hooks.run("after-tokenize",t),W.stringify(M.util.encode(t.tokens),t.language)},tokenize:function(e,n){var r=n.rest;if(r){for(var t in r)n[t]=r[t];delete n.rest}var a=new i;return I(a,a.head,e),function e(n,r,t,a,i,l){for(var o in t)if(t.hasOwnProperty(o)&&t[o]){var s=t[o];s=Array.isArray(s)?s:[s];for(var u=0;u<s.length;++u){if(l&&l.cause==o+","+u)return;var c=s[u],g=c.inside,f=!!c.lookbehind,h=!!c.greedy,d=c.alias;if(h&&!c.pattern.global){var v=c.pattern.toString().match(/[imsuy]*$/)[0];c.pattern=RegExp(c.pattern.source,v+"g")}for(var p=c.pattern||c,m=a.next,y=i;m!==r.tail&&!(l&&y>=l.reach);y+=m.value.length,m=m.next){var k=m.value;if(r.length>n.length)return;if(!(k instanceof W)){var b,x=1;if(h){if(!(b=z(p,y,n,f)))break;var w=b.index,A=b.index+b[0].length,P=y;for(P+=m.value.length;P<=w;)m=m.next,P+=m.value.length;if(P-=m.value.length,y=P,m.value instanceof W)continue;for(var S=m;S!==r.tail&&(P<A||"string"==typeof S.value);S=S.next)x++,P+=S.value.length;x--,k=n.slice(y,P),b.index-=y}else if(!(b=z(p,0,k,f)))continue;var w=b.index,E=b[0],O=k.slice(0,w),L=k.slice(w+E.length),N=y+k.length;l&&N>l.reach&&(l.reach=N);var j=m.prev;O&&(j=I(r,j,O),y+=O.length),q(r,j,x);var C=new W(o,g?M.tokenize(E,g):E,d,E);if(m=I(r,j,C),L&&I(r,m,L),1<x){var _={cause:o+","+u,reach:N};e(n,r,t,m.prev,y,_),l&&_.reach>l.reach&&(l.reach=_.reach)}}}}}}(e,a,n,a.head,0),function(e){var n=[],r=e.head.next;for(;r!==e.tail;)n.push(r.value),r=r.next;return n}(a)},hooks:{all:{},add:function(e,n){var r=M.hooks.all;r[e]=r[e]||[],r[e].push(n)},run:function(e,n){var r=M.hooks.all[e];if(r&&r.length)for(var t,a=0;t=r[a++];)t(n)}},Token:W};function W(e,n,r,t){this.type=e,this.content=n,this.alias=r,this.length=0|(t||"").length}function z(e,n,r,t){e.lastIndex=n;var a=e.exec(r);if(a&&t&&a[1]){var i=a[1].length;a.index+=i,a[0]=a[0].slice(i)}return a}function i(){var e={value:null,prev:null,next:null},n={value:null,prev:e,next:null};e.next=n,this.head=e,this.tail=n,this.length=0}function I(e,n,r){var t=n.next,a={value:r,prev:n,next:t};return n.next=a,t.prev=a,e.length++,a}function q(e,n,r){for(var t=n.next,a=0;a<r&&t!==e.tail;a++)t=t.next;(n.next=t).prev=n,e.length-=a}if(u.Prism=M,W.stringify=function n(e,r){if("string"==typeof e)return e;if(Array.isArray(e)){var t="";return e.forEach(function(e){t+=n(e,r)}),t}var a={type:e.type,content:n(e.content,r),tag:"span",classes:["token",e.type],attributes:{},language:r},i=e.alias;i&&(Array.isArray(i)?Array.prototype.push.apply(a.classes,i):a.classes.push(i)),M.hooks.run("wrap",a);var l="";for(var o in a.attributes)l+=" "+o+'="'+(a.attributes[o]||"").replace(/"/g,"&quot;")+'"';return"<"+a.tag+' class="'+a.classes.join(" ")+'"'+l+">"+a.content+"</"+a.tag+">"},!u.document)return u.addEventListener&&(M.disableWorkerMessageHandler||u.addEventListener("message",function(e){var n=JSON.parse(e.data),r=n.language,t=n.code,a=n.immediateClose;u.postMessage(M.highlight(t,M.languages[r],r)),a&&u.close()},!1)),M;var e=M.util.currentScript();function r(){M.manual||M.highlightAll()}if(e&&(M.filename=e.src,e.hasAttribute("data-manual")&&(M.manual=!0)),!M.manual){var t=document.readyState;"loading"===t||"interactive"===t&&e&&e.defer?document.addEventListener("DOMContentLoaded",r):window.requestAnimationFrame?window.requestAnimationFrame(r):window.setTimeout(r,16)}return M}(_self);"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
    Prism.languages.lua={comment:/^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,string:{pattern:/(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,greedy:!0},number:/\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,keyword:/\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,function:/(?!\d)\w+(?=\s*(?:[({]))/,operator:[/[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,{pattern:/(^|[^.])\.\.(?!\.)/,lookbehind:!0}],punctuation:/[\[\](){},;]|\.+|:+/};
    
    !function(){if("undefined"!=typeof self&&self.Prism&&self.document&&document.querySelector){var t,o="line-numbers",s="linkable-line-numbers",a=function(){if(void 0===t){var e=document.createElement("div");e.style.fontSize="13px",e.style.lineHeight="1.5",e.style.padding="0",e.style.border="0",e.innerHTML="&nbsp;<br />&nbsp;",document.body.appendChild(e),t=38===e.offsetHeight,document.body.removeChild(e)}return t},l=!0,u=0;Prism.hooks.add("before-sanity-check",function(e){var t=e.element.parentElement;if(c(t)){var n=0;v(".line-highlight",t).forEach(function(e){n+=e.textContent.length,e.parentNode.removeChild(e)}),n&&/^( \n)+$/.test(e.code.slice(-n))&&(e.code=e.code.slice(0,-n))}}),Prism.hooks.add("complete",function e(t){var n=t.element.parentElement;if(c(n)){clearTimeout(u);var i=Prism.plugins.lineNumbers,r=t.plugins&&t.plugins.lineNumbers;if(b(n,o)&&i&&!r)Prism.hooks.add("line-numbers",e);else d(n)(),u=setTimeout(f,1)}}),window.addEventListener("hashchange",f),window.addEventListener("resize",function(){v("pre").filter(c).map(function(e){return d(e)}).forEach(y)})}function v(e,t){return Array.prototype.slice.call((t||document).querySelectorAll(e))}function b(e,t){return e.classList.contains(t)}function y(e){e()}function c(e){return!(!e||!/pre/i.test(e.nodeName))&&(!!e.hasAttribute("data-line")||!(!e.id||!Prism.util.isActive(e,s)))}function d(u,e,c){var t=(e="string"==typeof e?e:u.getAttribute("data-line")||"").replace(/\s+/g,"").split(",").filter(Boolean),d=+u.getAttribute("data-line-offset")||0,f=(a()?parseInt:parseFloat)(getComputedStyle(u).lineHeight),p=Prism.util.isActive(u,o),n=u.querySelector("code"),h=p?u:n||u,m=[],g=n&&h!=n?function(e,t){var n=getComputedStyle(e),i=getComputedStyle(t);function r(e){return+e.substr(0,e.length-2)}return t.offsetTop+r(i.borderTopWidth)+r(i.paddingTop)-r(n.paddingTop)}(u,n):0;t.forEach(function(e){var t=e.split("-"),n=+t[0],i=+t[1]||n,r=u.querySelector('.line-highlight[data-range="'+e+'"]')||document.createElement("div");if(m.push(function(){r.setAttribute("aria-hidden","true"),r.setAttribute("data-range",e),r.className=(c||"")+" line-highlight"}),p&&Prism.plugins.lineNumbers){var o=Prism.plugins.lineNumbers.getLine(u,n),s=Prism.plugins.lineNumbers.getLine(u,i);if(o){var a=o.offsetTop+g+"px";m.push(function(){r.style.top=a})}if(s){var l=s.offsetTop-o.offsetTop+s.offsetHeight+"px";m.push(function(){r.style.height=l})}}else m.push(function(){r.setAttribute("data-start",String(n)),n<i&&r.setAttribute("data-end",String(i)),r.style.top=(n-d-1)*f+g+"px",r.textContent=new Array(i-n+2).join(" \n")});m.push(function(){h.appendChild(r)})});var i=u.id;if(p&&Prism.util.isActive(u,s)&&i){b(u,s)||m.push(function(){u.classList.add(s)});var r=parseInt(u.getAttribute("data-start")||"1");v(".line-numbers-rows > span",u).forEach(function(e,t){var n=t+r;e.onclick=function(){var e=i+"."+n;l=!1,location.hash=e,setTimeout(function(){l=!0},1)}})}return function(){m.forEach(y)}}function f(){var e=location.hash.slice(1);v(".temporary.line-highlight").forEach(function(e){e.parentNode.removeChild(e)});var t=(e.match(/\.([\d,-]+)$/)||[,""])[1];if(t&&!document.getElementById(e)){var n=e.slice(0,e.lastIndexOf(".")),i=document.getElementById(n);if(i)i.hasAttribute("data-line")||i.setAttribute("data-line",""),d(i,t,"temporary ")(),l&&document.querySelector(".temporary.line-highlight").scrollIntoView()}}}();
    !function(){var i=Object.assign||function(e,n){for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t]);return e};function e(e){this.defaults=i({},e)}function s(e){for(var n=0,t=0;t<e.length;++t)e.charCodeAt(t)=="\t".charCodeAt(0)&&(n+=3);return e.length+n}e.prototype={setDefaults:function(e){this.defaults=i(this.defaults,e)},normalize:function(e,n){for(var t in n=i(this.defaults,n)){var r=t.replace(/-(\w)/g,function(e,n){return n.toUpperCase()});"normalize"!==t&&"setDefaults"!==r&&n[t]&&this[r]&&(e=this[r].call(this,e,n[t]))}return e},leftTrim:function(e){return e.replace(/^\s+/,"")},rightTrim:function(e){return e.replace(/\s+$/,"")},tabsToSpaces:function(e,n){return n=0|n||4,e.replace(/\t/g,new Array(++n).join(" "))},spacesToTabs:function(e,n){return n=0|n||4,e.replace(RegExp(" {"+n+"}","g"),"\t")},removeTrailing:function(e){return e.replace(/\s*?$/gm,"")},removeInitialLineFeed:function(e){return e.replace(/^(?:\r?\n|\r)/,"")},removeIndent:function(e){var n=e.match(/^[^\S\n\r]*(?=\S)/gm);return n&&n[0].length?(n.sort(function(e,n){return e.length-n.length}),n[0].length?e.replace(RegExp("^"+n[0],"gm"),""):e):e},indent:function(e,n){return e.replace(/^[^\S\n\r]*(?=\S)/gm,new Array(++n).join("\t")+"$&")},breakLines:function(e,n){n=!0===n?80:0|n||80;for(var t=e.split("\n"),r=0;r<t.length;++r)if(!(s(t[r])<=n)){for(var i=t[r].split(/(\s+)/g),o=0,a=0;a<i.length;++a){var l=s(i[a]);n<(o+=l)&&(i[a]="\n"+i[a],o=l)}t[r]=i.join("")}return t.join("\n")}},"undefined"!=typeof module&&module.exports&&(module.exports=e),"undefined"!=typeof Prism&&(Prism.plugins.NormalizeWhitespace=new e({"remove-trailing":!0,"remove-indent":!0,"left-trim":!0,"right-trim":!0}),Prism.hooks.add("before-sanity-check",function(e){var n=Prism.plugins.NormalizeWhitespace;if((!e.settings||!1!==e.settings["whitespace-normalization"])&&Prism.util.isActive(e.element,"whitespace-normalization",!0))if(e.element&&e.element.parentNode||!e.code){var t=e.element.parentNode;if(e.code&&t&&"pre"===t.nodeName.toLowerCase()){for(var r=t.childNodes,i="",o="",a=!1,l=0;l<r.length;++l){var s=r[l];s==e.element?a=!0:"#text"===s.nodeName&&(a?o+=s.nodeValue:i+=s.nodeValue,t.removeChild(s),--l)}if(e.element.children.length&&Prism.plugins.KeepMarkup){var c=i+e.element.innerHTML+o;e.element.innerHTML=n.normalize(c,e.settings),e.code=e.element.textContent}else e.code=i+e.code+o,e.code=n.normalize(e.code,e.settings)}}else e.code=n.normalize(e.code,e.settings)}))}();
</script>

<style>
/* PrismJS 1.23.0
https://prismjs.com/download.html#themes=prism&languages=lua+moonscript&plugins=line-highlight+line-numbers */
/**
* prism.js default theme for JavaScript, CSS and HTML
* Based on dabblet (http://dabblet.com)
* @author Lea Verou
*/

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    font-size: 1em;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;

    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;

    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.token.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    /* This background color was intended by the author of this theme. */
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}

pre[data-line] {
    position: relative;
    padding: 1em 0 1em 3em;
}

.line-highlight {
    position: absolute;
    left: 0;
    right: 0;
    padding: inherit 0;
    margin-top: 1em; /* Same as .prism’s padding-top */

    background: hsla(24, 20%, 50%,.08);
    background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));

    pointer-events: none;

    line-height: inherit;
    white-space: pre;
}

@media print {
    .line-highlight {
        /*
        * This will prevent browsers from replacing the background color with white.
        * It's necessary because the element is layered on top of the displayed code.
        */
        -webkit-print-color-adjust: exact;
        color-adjust: exact;
    }
}

    .line-highlight:before,
    .line-highlight[data-end]:after {
        content: attr(data-start);
        position: absolute;
        top: .4em;
        left: .6em;
        min-width: 1em;
        padding: 0 .5em;
        background-color: hsla(24, 20%, 50%,.4);
        color: hsl(24, 20%, 95%);
        font: bold 65%/1.5 sans-serif;
        text-align: center;
        vertical-align: .3em;
        border-radius: 999px;
        text-shadow: none;
        box-shadow: 0 1px white;
    }

    .line-highlight[data-end]:after {
        content: attr(data-end);
        top: auto;
        bottom: .4em;
    }

.line-numbers .line-highlight:before,
.line-numbers .line-highlight:after {
    content: none;
}

pre[id].linkable-line-numbers span.line-numbers-rows {
    pointer-events: all;
}
pre[id].linkable-line-numbers span.line-numbers-rows > span:before {
    cursor: pointer;
}
pre[id].linkable-line-numbers span.line-numbers-rows > span:hover:before {
    background-color: rgba(128, 128, 128, .2);
}

pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

.line-numbers-rows > span {
    display: block;
    counter-increment: linenumber;
}

.line-numbers-rows > span:before {
    content: counter(linenumber);
    color: #999;
    display: block;
    padding-right: 0.8em;
    text-align: right;
}
</style>

</head>
<body>
    <!-- 
    TODO
    > * Show you the types of identifiers on hover.
    > * Take you to the definition of a variable on click.
    > * Both of these work cross-package.
    Basically use the teal compiler to extract all of this at compile time,

    Cross-package is going to be more tricky
    -->
    <pre id="code" class="linkable-line-numbers">
        <code class="language-lua">
local logger = require(&#039;tealdoc.logger&#039;)
local tl = require(&#039;tl&#039;)

--- A structure that represents a bare function
local record Function
   params: {Type}
   returns: {Type}
   vararg: boolean
   isMetamethod: boolean
end

--- A structure that represents a bare record or table
local record Struct
   fields: {string: Type}
   isRecord: boolean
end

--- A structure that represents every type
local record Type
   --- A list of all valid type names
   enum Kinds
      &#039;nil&#039;
      &#039;boolean&#039;
      &#039;number&#039;
      &#039;string&#039;
      &#039;userdata&#039;
      &#039;thread&#039;
      &#039;table&#039;
      --- Explicit type as any
      &#039;any&#039;
      --- A type which couldn&#039;t be figured out
      &#039;unknown&#039;
      --- Either an inline function or an actual function
      &#039;function&#039;
      --- A custom type like a record or module
      &#039;custom&#039;
      --- A union type that combines multiple types
      &#039;union&#039;
      --- A table which must contain a certain number of types in the correct order
      &#039;tuple&#039;
      &#039;poly&#039;
      --- A reference to another type
      &#039;nominal&#039;
      --- A list of strings of what the string could be
      &#039;enum&#039;
      --- A generic found within function definitions
      &#039;generic&#039;
   end

   --- The kind of type this is
   kind: Kinds
   --- The description of the type, every type can have a description since of records
   description: string
   --- The name of the type, usually inherited from their parent
   name: string
   --- The parent of the type, this doesn&#039;t exist for top-level types
   parent: Type | nil
   --- The file-system tree that needs to be followed
   tree: string
   --- The Y position of a type
   yPos: number | nil
   --- The stopping point of a type
   stopY: number | nil
   --- The source of where the type was found
   source: string | nil
   --- Exists on function types
   func: Function | nil
   --- Either a record or a module
   struct: Struct
   --- The key of the table
   key: Type | nil
   --- The value of the table
   value: Type | nil
   --- The types that form this type, eg `type1 | type2` or `{type1, type2}`
   types: {Type} | nil
   --- The values of an enum, its separate from types due to enums being &quot;complex&quot; aka blocked
   values: {Type} | nil
   --- A reference to another type
   ref: Type | nil
end

local record State
   report: tl.TypeReport
   files: {string: string}
end

-- Token isn&#039;t exposed
local record Token
   x: number
   y: number
   i: number
   tk: string
   kind: string
end

local function generateGlobals(modules: {string}): string
   local mod = {&#039;global toLoad = {&#039;}

   for i = 1, #modules do
      local str = modules[i]
      -- globals are easier to find
      table.insert(mod, &#039;[&quot;&#039; .. str .. &#039;&quot;] = require \&#039;&#039; .. str .. &#039;\&#039;,&#039;)
   end

   table.insert(mod, &#039;}&#039;)

   return table.concat(mod, &#039;\n&#039;)
end

-- Replaces teals search for one which indexes the virtual modules
local function newSearch(modules: {string: string}, virtual: boolean, state: State): function(module: string): string, FILE, {string}
   return function(module: string): string, FILE, {string}
      if modules[module] then
         local mod = modules[module]

         local f: FILE
         local filename: string

         -- Virtual
         if virtual then 
            local name = os.tmpname() .. &#039;.tl&#039;
            do
               local tmp = io.open(name, &#039;w&#039;)
               tmp:write(mod)
               tmp:close()
               state.files[name] = mod
            end
            f = io.open(name, &#039;r&#039;)
            filename = name
         else
            do
               local tmp = io.open(mod, &#039;r&#039;)
               state.files[mod] = tmp:read(&#039;*a&#039;)
               tmp:close()
            end
            f = io.open(mod, &#039;r&#039;)
            filename = mod
         end

         return filename, f
      else 
         return nil, nil, {&#039;We tried everything...&#039;}
      end
   end
end

--- Get a report on all the files
---
--- The report contains all indexed files as well as the types
---
--- If the modules being passed don&#039;t exist on disk, pass `true` to the virtual flag
---
--- If the files are Lua, pass `true` to the isLua flag
local function getReport(modules: {string: string}, virtual: boolean, isLua: boolean): State
   local keys: {string} = {}

   for i in pairs(modules) do
      table.insert(keys, i)
   end

   local str = generateGlobals(keys)

   local oldSearch = tl.search_module

   local state: State = {
      files = {}
   }

   tl.search_module = newSearch(modules, virtual, state)

   local result = tl.process_string(str, isLua)

   if #result.syntax_errors &gt; 1 then
      for i= 1, #result.syntax_errors do
         logger.error(result.syntax_errors[i].msg)
      end

      os.exit(-1)
   end

   local types = tl.get_types(result)

   tl.search_module = oldSearch

   state.report = types

   return state
end

--- Extract all the indexes of generated modules
local function extractModules(state: State, mods: {string: string}): {string: number}
   local collected: {string: number} = {}

   local pos = state.report.globals.toLoad

   for i, v in pairs(state.report.types[pos].fields) do
      if mods[i] then
         collected[i] = v
      end
   end

   return collected
end

local function getDescription(contents: string, y: number): string
   local split = {}

   do
      local pos = 1

      while true do
         local nextNewline = contents:find(&#039;\n&#039;, pos, true)

         if not nextNewline then
            break
         end

         table.insert(split, contents:sub(pos, nextNewline - 1))

         pos = nextNewline + 1
      end
   end

   local descLines: {string} = {}

   local i = y - 1

   while true do
      local line = split[i]

      if i &lt; 0 then
         break
      else
         i = i - 1

         if line and line:match(&#039;%s*%-%-%-%.*&#039;) then
            table.insert(descLines, line:match(&#039;%s*%-%-%- ?(.*)&#039;))
         else
            break
         end
      end
   end

   local reversed = {}

   for i = #descLines, 1, -1 do
      table.insert(reversed, descLines[i])
   end

   return table.concat(reversed, &#039;\n&#039;)
end

local function getTokensAtLine(tokens: {Token}, y: number, x: number): {Token}, {Token}
   --; TODO, use a binary search
   local started = false
   local tokensAtSig = {}
   local before = {}

   for i = 1, #tokens do
      local token = tokens[i]

      if token.y == y and token.x &gt;= x then
         started = true
         table.insert(tokensAtSig, token)
      elseif token.y ~= y and started then
         break
      elseif not started then
         table.insert(before, token)
      end
   end

   return tokensAtSig, before
end

local function getTokensBetween(tokens: {Token}, y1: number, y2: number, x1: number, x2: number): {Token}
   --; TODO, use a binary search
   local started = false
   local tokensBetween = {}

   for i = 1, #tokens do
      local token = tokens[i]

      if token.y &gt;= y1 and token.x &gt;= x1 then
         started = true
      end

      if token.y &gt; y2 or (token.y == y2 and token.x &gt;= x2) then
         break
      end

      if started then
         table.insert(tokensBetween, token)
      end
   end

   return tokensBetween
end

local function getStop(tokens: {Token}, y: number, x: number, allowFunction: boolean): Token, number
   local canStart = false
   local started = false

   -- These are what you can use **within a record** which can open a scope
   local opensScope: {string: boolean} = {
      [&#039;enum&#039;] = true,
      [&#039;record&#039;] = true,
      -- This expects a record and records can only have inline functions
      [&#039;function&#039;] = allowFunction
   }

   local deepness = 0
   local lastToken: Token

   for i = 1, #tokens do
      local token = tokens[i]

      if token.y == y and token.x &gt;= x then
         canStart = true
      end

      if canStart and opensScope[token.tk] then
         started = true
      end

      if started and (token.kind == &#039;keyword&#039; and token.tk == &#039;end&#039;) then
         deepness = deepness - 1
      elseif started and opensScope[token.tk] then
         deepness = deepness + 1
      end

      if started and deepness == 0 then
         lastToken = token

         return lastToken, i
      end
   end
end

local function getWithinTable(tokens: {Token}, y: number, x: number): {Token}, number
   local started = false
   local within = {}

   local stack = 1

   for i = 1, #tokens do
      local token = tokens[i]

      if started then
         if token.kind == &#039;{&#039; then
            stack = stack + 1
         elseif token.kind == &#039;}&#039; then
            stack = stack - 1
         end

         if stack &gt; 0 then
            table.insert(within, token)
         end
      elseif token.x == x and token.y == y then
         started = true
      end

      if stack == 0 and started then
         return within, i
      end
   end
end

--- Create a (parsable) type from an index and a report
local function createType(index: number, report: State, noNominal: boolean): Type
   local tp = report.report.types[index]
   local codes = tl.typecodes

   local conversions: {number: Type.kind} = {
      [codes.NIL] = &#039;nil&#039;,
      [codes.BOOLEAN] = &#039;boolean&#039;,
      [codes.NUMBER] = &#039;number&#039;,
      [codes.STRING] = &#039;string&#039;,
      [codes.USERDATA] = &#039;userdata&#039;,
      [codes.THREAD] = &#039;thread&#039;,
      [codes.TABLE] = &#039;table&#039;,
      [codes.ANY] = &#039;any&#039;,
      [codes.UNKNOWN] = &#039;unknown&#039;
   }

   local out: Type

   if conversions[tp.t] then
      -- Basic type
      out = {
         kind = conversions[tp.t]
      }
   elseif tp.t == codes.FUNCTION then
      local tokens = tl.lex(report.files[tp.file])

      local paramNames = {}

      local started = false
      local tokensAtSig = getTokensAtLine(tokens as {Token}, tp.y, tp.x)

      for i = 1, #tokensAtSig do
         local token = tokensAtSig[i]
         if token.tk == &#039;(&#039; then
            started = true
         elseif started and token.tk == &#039;)&#039; then
            break
         elseif started and (token.kind == &#039;identifier&#039; or token.kind == &#039;...&#039;) and (tokensAtSig[i - 1].kind == &#039;,&#039; or tokensAtSig[i - 1].kind == &#039;(&#039;) then
            table.insert(paramNames, tokensAtSig[i].tk)
         end
      end

      local params = {}

      for i = 1, #tp.args do
         local argType = createType(tp.args[i][1], report, noNominal)

         argType.name = paramNames[i]
         table.insert(params, argType)
      end

      local rets = {}

      for i = 1, #tp.rets do
         table.insert(rets, createType(tp.rets[i][1], report, noNominal))
      end

      --; TODO - get functions stop

      out = {
         kind = &#039;function&#039;,
         description = getDescription(report.files[tp.file], tp.y),
         source = tp.file,
         yPos = tp.y,
         func = {
            params = params,
            returns = rets,
            vararg = tp.vararg
         }
      }
   elseif tp.t == codes.ARRAY then
      out = {
         kind = &#039;table&#039;,
         key = {
            kind = &#039;number&#039;
         },
         value = createType(tp.elements, report, noNominal)
      }
   elseif tp.t == codes.RECORD or tp.t == codes.ARRAYRECORD then
      local tokens = tl.lex(report.files[tp.file])

      local tokensAtSig, before = getTokensAtLine(tokens as {Token}, tp.y, tp.x)

      local name: string
      local lastSig = tokens[#tokensAtSig + #before + 1] as Token

      local isRecord = false

      for i = 1, #tokensAtSig do
         if tokensAtSig[i].tk == &#039;record&#039; then
            isRecord = true
         end

         if tokensAtSig[i].kind == &#039;identifier&#039; and tokensAtSig[i - 1] and tokensAtSig[i - 1].tk == &#039;record&#039; then
            name = tokensAtSig[i].tk
            break
         end
      end

      if not name then
         -- It&#039;s a sub-record
         if before[#before].kind == &#039;identifier&#039; and before[#before - 1] and before[#before - 1].tk == &#039;record&#039; then
            name = before[#before].tk
            -- Correct the X position to include `record`
            tp.x = before[#before - 1].x
            -- Same with the Y
            tp.y = before[#before - 1].y

            lastSig = tokensAtSig[1]
         end
      end

      out = {
         kind = &#039;custom&#039;,
         name = name,
         description = getDescription(report.files[tp.file], tp.y),
         source = tp.file,
         yPos = tp.y,
         struct = {
            fields = {},
            isRecord = isRecord
         }
      }

      for i, v in pairs(tp.fields) do
         local typ = createType(v, report, noNominal)

         typ.name = i
         typ.parent = out

         out.struct.fields[i] = typ
      end

      if not name then
         -- This is a table

         local within = getWithinTable(tokens as {Token}, tp.y, tp.x)

         -- Here we cannot just jump to the next `=` since it could be within a function

         local i = 1

         local blocks: {string: boolean} = {
            [&#039;enum&#039;] = true,
            [&#039;record&#039;] = true,
            [&#039;function&#039;] = true
         }

         while i &lt;= #within do
            -- Blocks already have their descriptions filled out
            if within[i].kind == &#039;identifier&#039; and blocks[within[i + 2].tk] then
               local stack = 1

               for k = i + 3, #within do
                  local token = within[k]

                  if blocks[token.tk] then
                     stack = stack + 1
                  elseif token.kind == &#039;keyword&#039; and token.tk == &#039;end&#039; then
                     stack = stack - 1
                  end

                  if stack == 0 then
                     i = k + 2
                     break
                  end
               end
            elseif within[i + 2].kind == &#039;{&#039; then
               local _, stop = getWithinTable(tokens as {Token}, within[i + 2].y, within[i + 2].x)

               i = stop
            else
               -- A type
               local fieldToken = within[i]

               local found = false

               out.struct.fields[fieldToken.tk].description = getDescription(report.files[tp.file], fieldToken.y)

               for k = i + 3, #within do
                  -- Find next equal
                  -- We will not run into anything that could be a mistake here

                  if within[k].kind == &#039;op&#039; and within[k].tk == &#039;=&#039; then
                     i = k - 1

                     found = true
                  end
               end

               if not found then
                  break
               end
            end
         end
      else
         local lastToken = getStop(tokens as {Token}, tp.y, tp.x)

         out.stopY = lastToken.y

         local tokensBetween = getTokensBetween(tokens as {Token}, lastSig.y, lastToken.y, lastSig.x, lastToken.x)

         local i = 1

         while i &lt;= #tokensBetween do
            if tokensBetween[i].kind == &#039;identifier&#039; and (tokensBetween[i].tk == &#039;record&#039; or tokensBetween[i].tk == &#039;enum&#039;) and 
               tokensBetween[i + 1] and tokensBetween[i + 1].kind == &#039;identifier&#039; 
            then
               local _, pos = getStop(tokensBetween, tokensBetween[i].y, tokensBetween[i].x)

               -- They already get documented since they are records

               i = pos + 1
            else
               local fieldToken = tokensBetween[i]

               if fieldToken.tk == &#039;metamethod&#039; then
                  i = i + 1

                  out.struct.fields[tokensBetween[i].tk] = {
                     kind = &#039;function&#039;,
                     source = tp.file,
                     name = tokensBetween[i].tk,
                     yPos = fieldToken.y,
                     func = { --; TODO - Extract these
                              --; Teal doesn&#039;t expose metamethods within requires
                        params = {},
                        returns = {},
                        vararg = {},
                        isMetamethod = true
                     } as Function
                  }
               else

                  local found = false

                  --; FIXME - metamethod operators
                  local outField = out.struct.fields[fieldToken.tk]

                  outField.description = getDescription(report.files[tp.file], fieldToken.y)

                  local stack = 0
                  local ignoreNext = outField.kind == &#039;function&#039;
                  -- logger.debug(atLine)

                  for k = i + 2, #tokensBetween do
                     -- We need to watchout for composition types eg functions, tables

                     local token = tokensBetween[k]

                     if token.kind == &#039;{&#039; or token.kind == &#039;(&#039; then
                        stack = stack + 1
                     elseif token.kind == &#039;}&#039; or token.kind == &#039;)&#039; then
                        stack = stack - 1
                     end

                     if token.kind == &#039;:&#039; and token.tk == &#039;:&#039; and stack == 0 and not ignoreNext then
                        i = k - 1

                        found = true

                        break
                     elseif ignoreNext and token.kind == &#039;:&#039; and token.tk == &#039;:&#039; then
                        ignoreNext = false
                     end
                  end

                  if not found then
                     break
                  end
               end
            end
         end
      end
   elseif tp.t == codes.MAP then
      out = {
         kind = &#039;table&#039;,
         key = createType(tp.keys, report, noNominal),
         value = createType(tp.values, report, noNominal)
      }
   elseif tp.t == codes.TUPLE or tp.t == codes.IS_UNION or tp.t == codes.IS_POLY then
      local types = {}

      for i = 1, #tp.types do
         local parsed = createType(tp.types[i], report, noNominal)

         table.insert(types, parsed)
      end

      out = {
         kind =
            tp.t == codes.TUPLE and &#039;tuple&#039; or
            tp.t == codes.IS_UNION and &#039;union&#039; or
            tp.t == codes.IS_POLY and &#039;poly&#039;,
         types = types
      }
   elseif tp.t == codes.NOMINAL and not noNominal then
      -- Reference to another record
      -- As long as its not recursion we *should* be fine

      -- We don&#039;t set the parent on this one since it would be mostly pointless
      local ref = createType(tp.ref, report, true)

      out = {
         kind = &#039;nominal&#039;,
         ref = ref,
      }
   elseif tp.t == codes.ENUM then
      local tokens = tl.lex(report.files[tp.file])

      local tokensAtSig, before = getTokensAtLine(tokens as {Token}, tp.y, tp.x)

      local name: string
      local lastSig = tokens[#tokensAtSig + #before + 1] as Token

      for i = 1, #tokensAtSig do
         if tokensAtSig[i].kind == &#039;identifier&#039; and tokensAtSig[i - 1] and tokensAtSig[i - 1].tk == &#039;enum&#039; then
            name = tokensAtSig[i].tk
            break
         end
      end

      if not name then
         -- It&#039;s a sub-record
         if before[#before].kind == &#039;identifier&#039; and before[#before - 1] and before[#before - 1].tk == &#039;enum&#039; then
            name = before[#before].tk
            -- Correct the X position to include `record`
            tp.x = before[#before - 1].x
            -- Same with the Y
            tp.y = before[#before - 1].y

            lastSig = tokensAtSig[1]
         end
      end

      local lastToken = getStop(tokens as {Token}, tp.y, tp.x)

      local between = getTokensBetween(tokens as {Token}, lastSig.y, lastToken.y, lastSig.x, lastToken.x)

      local values = {}

      for i = 1, #between do
         local token = between[i]

         table.insert(values, {
            kind = &#039;string&#039;,
            name = token.tk,
            yPos = token.y,
            stopY = token.y,
            description = getDescription(report.files[tp.file], token.y)
         })
      end

      out = {
         kind = &#039;enum&#039;,
         values = values,
         name = name,
         description = getDescription(report.files[tp.file], tp.y),
         source = tp.file,
         yPos = tp.y
      }
   elseif tp.t == codes.TYPE_VARIABLE then
      out = {
         kind = &#039;generic&#039;,
         name = tp.str
      }
   else
      out = {
         kind = &#039;unknown&#039;
      }
   end

   out.tree = &#039;&#039;
   out.description = out.description or &#039;&#039;

   return out
end

--- Utilities for extracting all the types from either virtual files or real files
return {
   getReport = getReport,
   createType = createType,
   extractModules = extractModules,
   Type = Type,
   Function = Function,
   Struct = Struct
}

        </code>
    </pre>
</body>
</html>
